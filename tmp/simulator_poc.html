<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adebis Simulator</title>
    <!-- Sugar CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Rezi/sugar-css@main/dist/sugar.min.css" />
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Removed Highlight.js CSS (default theme) -->
    <!-- Removed Highlight.js Copy Button CSS -->

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f4f7f6;
            color: #333;
            margin: 0;
            padding: 0; /* Remove body padding as content will be managed by containers */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .container {
            background-color: #ffffff;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            padding: 30px;
            width: 100%;
            max-width: 900px;
            margin-bottom: 20px;
            box-sizing: border-box;
        }

        /* Top Navigation Styles */
        #topNav {
            background-color: #2c3e50;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between; /* Aligns items to start and end */
            align-items: center; /* Vertically center items */
            width: 100%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
            box-sizing: border-box; /* Include padding in width */
        }
        .nav-items-left {
            display: flex;
            align-items: center;
        }
        .nav-item {
            color: #ecf0f1;
            padding: 10px 20px;
            margin: 0 10px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            border-radius: 5px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .nav-item:hover {
            background-color: #34495e;
        }
        .nav-item.active {
            background-color: #3498db;
            color: white;
        }
        .nav-title {
            color: #ecf0f1;
            font-size: 1.8em; /* Adjusted size to fit nav bar */
            font-weight: bold;
            margin: 0; /* Remove default margins */
            padding-right: 10px; /* Add some padding from the right edge */
        }

        /* Main Content Area */
        #appContainer {
            flex-grow: 1; /* Allows this container to take up remaining vertical space */
            width: 100%;
            display: flex;
            justify-content: center;
            padding: 20px; /* Add padding to the main content area */
            box-sizing: border-box;
        }

        .tab-content {
            display: none; /* Hidden by default */
            width: 100%;
            max-width: 900px; /* Match container max-width */
        }
        .tab-content.active {
            display: block; /* Show active tab content */
        }

        /* Existing styles for forms, tables, modals */
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }
        input[type="file"] {
            display: block;
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
        }
        input[type="date"] { /* Added style for date inputs */
            display: block;
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
        }
        .checkbox-group label {
            display: flex;
            align-items: center;
            font-weight: normal;
            margin-bottom: 0;
            color: #555;
        }
        .checkbox-group input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
            width: auto;
        }
        button {
            background-color: #3498db;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #2980b9;
        }
        .message-box {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            border-radius: 5px;
            padding: 15px;
            margin-top: 20px;
            display: none;
            font-size: 0.9em;
        }
        .loading-spinner {
            display: none;
            text-align: center;
            margin-top: 20px;
            font-size: 1.2em;
            color: #555;
        }
        .data-overview h2 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.8em;
            text-align: center;
        }
        .import-icon-container {
            text-align: right;
            margin-bottom: 20px;
        }
        #importIcon {
            font-size: 2.5em;
            color: #3498db;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        #importIcon:hover {
            color: #2980b9;
        }

        .table-wrapper {
            border: 1px solid #eee;
            border-radius: 8px;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            background-color: #fff;
        }
        .data-table th, .data-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        .data-table th {
            background-color: #eef4f7;
            color: #333;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9em;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .data-table tbody tr:hover {
            background-color: #f5f8fa;
            cursor: pointer;
        }
        .data-table tbody tr.selected {
            background-color: #d1ecf1;
        }
        .data-table .no-data-row td {
            text-align: center;
            padding: 20px;
            color: #777;
            font-style: italic;
        }

        /* Detail Panel */
        .detail-panel {
            position: fixed;
            right: -60vw;
            width: 60vw;
            background-color: #ffffff;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.15);
            transition: right 0.3s ease-in-out;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            z-index: 1000;
            border-left: 1px solid #eee;
            /* top and height set by JS */
        }
        .detail-panel.open {
            right: 0;
        }
        .detail-panel-header {
            display: flex;
            align-items: center; /* Vertically align title and button */
            justify-content: flex-start;
            margin-bottom: 20px;
            position: relative; /* Crucial for absolute positioning of close-btn */
        }
        .detail-panel-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 1.5em;
            flex-grow: 1; /* Allow title to take up available space */
            padding-right: 40px; /* Ensure space for the close button */
        }
        .close-btn {
            background: none;
            border: none;
            font-size: 1.2em;
            cursor: pointer;
            color: #777;
            transition: color 0.3s ease;
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 5px;
            line-height: 1;
            display: none; /* Hidden by default */
        }
        .close-btn:hover {
            color: #333;
        }
        .detail-content {
            margin-top: 20px;
        }

        /* Raw Data Section: Adjusted padding for highlight.js */
        .rawdata-section {
            position: relative;
            margin-bottom: 20px;
        }
        .rawdata-section h5 {
            margin-bottom: 5px;
        }
        .rawdata-section pre {
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            padding: 15px; /* Base padding */
            border-radius: 8px;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.9em;
            line-height: 1.6;
            color: #444;
            max-height: 200px;
            overflow-y: auto;
            /* highlight.js adds its own padding, so we can keep base padding */
        }

        /* Detail Panel Tabs */
        .detail-nav {
            display: flex;
            border-bottom: 1px solid #eee;
            margin-bottom: 15px;
        }
        .detail-nav-item {
            padding: 10px 15px;
            cursor: pointer;
            font-weight: bold;
            color: #777;
            border-bottom: 2px solid transparent;
            transition: border-color 0.3s ease, color 0.3s ease;
        }
        .detail-nav-item:hover {
            color: #333;
        }
        .detail-nav-item.active {
            color: #3498db;
            border-bottom-color: #3498db;
        }
        .detail-tab-pane {
            display: none;
        }
        .detail-tab-pane.active {
            display: block;
        }
        /* Styles for the new form elements in detail panel's "Daten" tab */
        #parsedDataTab {
            max-height: calc(100vh - 350px); /* Added max-height for scrolling */
            overflow-y: auto; /* Added overflow-y for scrolling */
            padding-right: 15px; /* Add padding for scrollbar */
        }
        #parsedDataTab .form-group {
            margin-bottom: 15px;
        }
        #parsedDataTab label {
            font-weight: normal;
            color: #333;
            margin-bottom: 5px;
        }
        #parsedDataTab button {
            margin-top: 20px;
            width: 100%;
        }
        #detailDateMessage {
            margin-top: 15px;
        }

        /* New styles for date pickers side-by-side */
        .date-picker-group {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .date-picker-group .form-group {
            flex: 1;
            margin-bottom: 0;
        }

        /* Styles for Booking Card and Group Card (reused) */
        .booking-card, .group-card {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background-color: #fcfcfc;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .booking-card-header, .group-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .booking-card-header h5, .group-card-header h5 {
            margin: 0;
            font-size: 1.1em;
            color: #333;
        }
        .booking-card-actions, .group-card-actions {
            display: flex;
            gap: 10px;
        }
        .booking-card-actions i, .group-card-actions i {
            cursor: pointer;
            font-size: 1.2em;
            color: #777;
            transition: color 0.2s ease;
        }
        .booking-card-actions i:hover, .group-card-actions i:hover {
            color: #3498db;
        }

        .booking-card-display-mode,
        .booking-card-edit-mode,
        .group-card-display-mode,
        .group-card-edit-mode {
            display: none;
        }
        .booking-card-display-mode.active,
        .booking-card-edit-mode.active,
        .group-card-display-mode.active,
        .group-card-edit-mode.active {
            display: block;
        }
        /* Compact display mode styling */
        .booking-card-display-mode p, .group-card-display-mode p {
            margin: 0;
            font-size: 0.95em;
            line-height: 1.4;
            color: #555;
        }

        /* Styles for the sliders within booking card */
        .booking-card details {
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-bottom: 10px;
            background-color: #f9f9f9;
        }
        .booking-card summary {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding: 10px 15px;
            cursor: pointer;
            font-weight: bold;
            color: #333;
            gap: 8px;
            list-style: none;
        }
        .booking-card summary::-webkit-details-marker {
            display: none;
        }
        .booking-card input[type="range"] {
            width: 100%;
            margin-top: 10px;
        }
        .booking-card .slider-container-content {
            padding: 10px 15px;
            margin-top: 15px;
        }
        .booking-card details[disabled] {
            opacity: 0.6;
        }

        /* Group card specific styles for dropdown */
        .group-card select {
            display: block;
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            margin-top: 10px;
        }

        /* New styles for inline group assignment dropdown */
        .booking-card .group-assignment-per-day {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px; /* Space above this group */
            margin-bottom: 5px; /* Space below this group */
        }
        .booking-card .group-assignment-per-day label {
            margin-bottom: 0;
            white-space: nowrap;
            font-weight: normal; /* Override bold from general label */
        }
        .booking-card .group-assignment-per-day select {
            flex-grow: 1;
            width: auto; /* Allow it to shrink/grow */
            max-width: 150px; /* Optional: limit max width */
            padding: 8px 10px; /* Adjust padding for smaller size */
            font-size: 0.9em; /* Smaller font size */
        }


        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s forwards;
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
            position: relative;
            animation: slideInTop 0.3s forwards;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .modal-header h2 {
            margin: 0;
            color: #2c3e50;
            font-size: 1.8em;
        }

        .close-modal-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-modal-btn:hover,
        .close-modal-btn:focus {
            color: #333;
            text-decoration: none;
            cursor: pointer;
        }

        .modal-body button {
            width: auto;
            margin-top: 25px;
            display: block;
            margin-left: auto;
            margin-right: 0;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideInTop {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            .nav-title {
                font-size: 1.4em;
            }
            .nav-item {
                padding: 8px 15px;
                font-size: 1em;
            }
            .modal-body button {
                width: 100%;
                margin-left: 0;
                margin-right: 0;
            }
            .detail-panel {
                width: 100%;
                right: -100%;
            }
            .detail-panel.open {
                right: 0;
            }
            .modal-content {
                width: 95%;
                padding: 20px;
            }
            .date-picker-group {
                flex-direction: column;
                gap: 0;
            }
        }

        /* Styles for modified elements */
        .modified-input {
            border: 2px solid #28a745 !important;
            box-shadow: 0 0 5px rgba(40, 167, 69, 0.5);
        }

        .modified-checkbox + div { /* For the summary text of details element */
            color: #28a745 !important;
            font-weight: bold;
        }

        .modified-select {
            border: 2px solid #28a745 !important;
            box-shadow: 0 0 5px rgba(40, 167, 69, 0.5);
        }

        .modified-card {
            border: 2px solid #28a745 !important;
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.5);
        }
    </style>
</head>
<body>
    <nav id="topNav">
        <div class="nav-items-left">
            <div class="nav-item active" data-tab="dataTabContent">Daten</div>
            <div class="nav-item" data-tab="simulationTabContent">Simulation</div>
        </div>
        <div class="nav-title">Adebis Simulator</div>
    </nav>

    <div id="appContainer">
        <div id="dataTabContent" class="tab-content active">
            <div id="dataOverview" class="container">
                <h2>Übersicht der Datensätze</h2>
                <div class="import-icon-container">
                    <i class="fas fa-file-upload" id="importIcon" title="Daten importieren"></i>
                </div>
                <div class="table-wrapper">
                    <table class="data-table" id="dataTable">
                        <thead>
                            <tr>
                                <th>Typ</th>
                                <th>Name</th>
                                <th>Startdatum</th>
                                <th>Enddatum</th>
                                <th>Datenquelle</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr class="no-data-row">
                                <td colspan="5">Keine Daten geladen. Bitte importieren Sie eine Datei.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div id="simulationTabContent" class="tab-content">
            <div class="container">
                <h2>Simulationsbereich</h2>
                <p>Dieser Bereich ist für zukünftige Simulationsfunktionen vorgesehen.</p>
            </div>
        </div>
    </div>

    <!-- Upload Modal -->
    <div id="uploadModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Export hochladen</h2>
                <span class="close-modal-btn">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="zipFile">Adebis Export ZIP hochladen:</label>
                    <input type="file" id="zipFile" accept=".zip">
                </div>

                <div class="s-grid checkbox-group" style="--span:6;">
                    <div>
                        <label>
                            <input type="checkbox" id="anonymizeCheckbox" checked>
                            Namen anonymisieren
                        </label>
                    </div>
                </div>

                <button id="uploadButton">Daten verarbeiten</button>

                <div id="messageBox" class="message-box"></div>
                <div id="loadingSpinner" class="loading-spinner">Daten werden verarbeitet...</div>
            </div>
        </div>
    </div>

    <div id="detailPanel" class="detail-panel">
        <div class="detail-panel-header">
            <h3 id="detailPanelTitle">Details</h3>
            <!-- The close button is now hidden by default via CSS -->
            <button class="close-btn" id="closeDetailPanel">&times;</button>
        </div>
        <div class="detail-nav">
            <div class="detail-nav-item active" data-detail-tab="parsedDataTab">Daten</div>
            <div class="detail-nav-item" data-detail-tab="rawDataTab">Rohdaten</div>
        </div>
        <div class="detail-content">
            <div id="parsedDataTab" class="detail-tab-pane active">
                <div class="date-picker-group">
                    <div class="form-group">
                        <label for="detailStartDate">Startdatum:</label>
                        <input type="date" id="detailStartDate" class="s-input">
                    </div>
                    <div class="form-group">
                        <label for="detailEndDate">Enddatum:</label>
                        <input type="date" id="detailEndDate" class="s-input">
                    </div>
                </div>

                <h4>Buchungszeiten:</h4>
                <div id="bookingCardsContainer">
                    <!-- Booking cards will be dynamically inserted here -->
                </div>

                <h4>Gruppen:</h4>
                <div id="groupCardsContainer">
                    <!-- Group cards will be dynamically inserted here -->
                </div>

                <button id="saveDetailDatesButton">Speichern</button>
                <button id="resetDetailButton" style="background-color: #e74c3c; margin-top: 10px;">Zurücksetzen</button>
                <div id="detailDateMessage" class="message-box"></div>
            </div>
            <div id="rawDataTab" class="detail-tab-pane">
                <div class="rawdata-section">
                    <h5>Rohdaten (Original):</h5>
                    <pre id="rawdataContent"></pre>
                </div>
                <div class="rawdata-section">
                    <h5>Geparsed Daten (Strukturiert):</h5>
                    <pre id="parseddataContent"></pre>
                </div>
                <div class="rawdata-section">
                    <h5>Modifikationen:</h5>
                    <pre id="modificationsContent"></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- JSZip Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <!-- Removed Highlight.js JS -->
    <!-- Removed Highlight.js JSON language definition -->
    <!-- Removed Highlight.js Copy Button JS -->

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Content Loaded!'); // Debugging: Check if script starts

            // --- Variable Declarations ---
            const zipFileInput = document.getElementById('zipFile');
            const anonymizeCheckbox = document.getElementById('anonymizeCheckbox');
            const uploadButton = document.getElementById('uploadButton');
            const messageBox = document.getElementById('messageBox');
            const loadingSpinner = document.getElementById('loadingSpinner');
            const dataTableBody = document.querySelector('#dataTable tbody');
            const detailPanel = document.getElementById('detailPanel');
            const closeDetailPanelBtn = document.getElementById('closeDetailPanel');
            const detailPanelTitle = document.getElementById('detailPanelTitle');
            const rawdataContent = document.getElementById('rawdataContent');
            const parseddataContent = document.getElementById('parseddataContent'); // New element for parsed data
            const modificationsContent = document.getElementById('modificationsContent'); // New element for modifications
            const dataOverview = document.getElementById('dataOverview');

            // Elements for the detail form's "Daten" tab
            const detailStartDateInput = document.getElementById('detailStartDate');
            const detailEndDateInput = document.getElementById('detailEndDate');
            const saveDetailDatesButton = document.getElementById('saveDetailDatesButton');
            const resetDetailButton = document.getElementById('resetDetailButton'); // New Reset button
            const detailDateMessage = document.getElementById('detailDateMessage');
            const bookingCardsContainer = document.getElementById('bookingCardsContainer'); // New container for booking cards
            const groupCardsContainer = document.getElementById('groupCardsContainer'); // New container for group cards

            // Modal specific elements
            const uploadModal = document.getElementById('uploadModal');
            const closeModalBtn = document.querySelector('.close-modal-btn');
            const importIcon = document.getElementById('importIcon'); // Corrected ID here

            // Navigation elements (moved here for guaranteed definition)
            const navItems = document.querySelectorAll('.nav-item');
            const tabContents = document.querySelectorAll('.tab-content');
            const detailNavItems = document.querySelectorAll('.detail-nav-item');
            const detailTabPanes = document.querySelectorAll('.detail-tab-pane');

            let processedData = [];
            let currentSelectedRowId = null;
            let currentSelectedItem = null; // Store the currently selected item for editing
            let groupsLookup = {}; // Global variable to store group ID to Name mapping


            // --- Helper Functions (moved to top for hoisting/definition guarantee) ---

            /**
             * Displays a message in the messageBox.
             * @param {string} message The message to display.
             * @param {string} type The type of message ('error' or 'success').
             */
            function showMessage(message, type = 'error') {
                messageBox.textContent = message;
                messageBox.style.display = 'block';
                messageBox.style.backgroundColor = type === 'error' ? '#f8d7da' : '#d4edda';
                messageBox.style.color = type === 'error' ? '#721c24' : '#155724';
            }

            /**
             * Hides the messageBox.
             */
            function hideMessage() {
                messageBox.style.display = 'none';
            }

            /**
             * Displays a message in the detailDateMessage box.
             * @param {string} message The message to display.
             * @param {string} type The type of message ('error' or 'success').
             */
            function showDetailMessage(message, type = 'error') {
                detailDateMessage.textContent = message;
                detailDateMessage.style.display = 'block';
                detailDateMessage.style.backgroundColor = type === 'error' ? '#f8d7da' : '#d4edda';
                detailDateMessage.style.color = type === 'error' ? '#721c24' : '#155724';
            }

            /**
             * Hides the detailDateMessage box.
             */
            function hideDetailMessage() {
                detailDateMessage.style.display = 'none';
            }

            /**
             * Shows the loading spinner and disables upload elements.
             */
            function showLoading() {
                loadingSpinner.style.display = 'block';
                uploadButton.disabled = true;
                zipFileInput.disabled = true;
            }

            /**
             * Hides the loading spinner and enables upload elements.
             */
            function hideLoading() {
                loadingSpinner.style.display = 'none';
                uploadButton.disabled = false;
                zipFileInput.disabled = false;
            }

            /**
             * Parses a DD.MM.YYYY date string into a Date object.
             * @param {string} dateString The date string in DD.MM.YYYY format.
             * @returns {Date|null} The parsed Date object or null if invalid.
             */
            function parseDate(dateString) {
                if (!dateString) return null;
                const parts = dateString.split('.');
                if (parts.length === 3) {
                    return new Date(parseInt(parts[2]), parseInt(parts[1]) - 1, parseInt(parts[0]));
                }
                return null;
            }

            /**
             * Converts a DD.MM.YYYY date string to YYYY-MM-DD format for date inputs.
             * @param {string} dateString The date string in DD.MM.YYYY format.
             * @returns {string} The formatted date string in YYYY-MM-DD format.
             */
            function convertDDMMYYYYtoYYYYMMDD(dateString) {
                if (!dateString) return '';
                const parts = dateString.split('.');
                if (parts.length === 3) {
                    return `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                }
                return '';
            }

            /**
             * Converts a YYYY-MM-DD date string to DD.MM.YYYY format for internal data.
             * @param {string} dateString The date string in YYYY-MM-DD format.
             * @returns {string} The formatted date string in DD.MM.YYYY format.
             */
            function convertYYYYMMDDtoDDMMYYYY(dateString) {
                if (!dateString) return '';
                const parts = dateString.split('-');
                if (parts.length === 3) {
                    return `${parts[2]}.${parts[1]}.${parts[0]}`;
                }
                return '';
            }

            /**
             * Checks if a date string is empty or represents a future date.
             * @param {string} dateString The date string to check.
             * @returns {boolean} True if empty or future, false otherwise.
             */
            function isFutureOrEmptyDate(dateString) {
                if (!dateString || dateString.trim() === '') {
                    return true;
                }
                const date = parseDate(dateString);
                if (!date) return false;
                const now = new Date();
                now.setHours(0, 0, 0, 0);
                return date >= now;
            }

            /**
             * Parses an XML string into a DOM object.
             * @param {string} xmlString The XML string.
             * @returns {Document} The parsed XML Document.
             */
            function parseXmlString(xmlString) {
                const parser = new DOMParser();
                return parser.parseFromString(xmlString, "text/xml");
            }

            /**
             * Gets the text content of an XML element by tag name.
             * @param {Document} xmlDoc The XML Document.
             * @param {string} tagName The tag name of the element.
             * @returns {string} The text content or an empty string if not found.
             */
            function getXmlValue(xmlDoc, tagName) {
                const element = xmlDoc.querySelector(tagName);
                return element ? element.textContent.trim() : '';
            }

            /**
             * Parses the ZEITEN string from XML into structured time objects.
             * Handles formats like "HH:MM|HH:MM|HH:MM|HH:MM#..." (start|break_start|break_end|end)
             * or "HH:MM|HH:MM#..." (start|end).
             * Extracts multiple time segments for a day.
             * @param {string} zeitenString The ZEITEN string.
             * @returns {Array<Object>} An array of parsed day objects, each containing an array of segments.
             * Example: [{ day: 1, day_name: "Mo", segments: [{ start: "07:30", end: "12:30", groupId: "" }, { start: "13:00", end: "17:30", groupId: "" }] }]
             */
            function parseZeiten(zeitenString) {
                console.log('Parsing zeitenString:', zeitenString);
                const daysRaw = zeitenString.split('#').filter(s => s.trim() !== '');
                const parsedDays = [];
                const dayNames = ['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'];

                daysRaw.forEach((dayStr, dayIndex) => {
                    if (dayIndex >= 5) return; // Only process Mon-Fri

                    const parts = dayStr.split('|').map(p => p.trim());
                    const segments = [];

                    // Iterate through parts in pairs to find start/end times
                    // A full day with break will have 4 parts: start1|end1|start2|end2
                    // A day without break will have 2 parts: start1|end1
                    // Empty parts like "" mean no time for that segment
                    for (let i = 0; i < parts.length; i += 2) {
                        const start = parts[i];
                        const end = parts[i + 1];

                        if (start && end) { // Both start and end must be present for a valid segment
                            segments.push({
                                booking_start: start,
                                booking_end: end,
                                groupId: '' // Initialize groupId for each segment
                            });
                        }
                    }

                    if (segments.length > 0) {
                        parsedDays.push({
                            day: dayIndex + 1,
                            day_name: dayNames[dayIndex],
                            segments: segments // Store multiple segments for the day
                        });
                    }
                });
                console.log('Final parsedDays:', parsedDays);
                return parsedDays;
            }

            /**
             * Adjusts the detail panel's position and height relative to the data overview.
             */
            function adjustDetailPanelPosition() {
                const dataOverviewRect = dataOverview.getBoundingClientRect();
                detailPanel.style.top = `${dataOverviewRect.top + window.scrollY}px`;
                detailPanel.style.height = `${dataOverviewRect.height}px`;
            }

            /**
             * Converts a slider value (0-47, representing half-hour intervals from 00:00) to HH:MM time string.
             * @param {number} value The slider value.
             * @returns {string} The formatted time string (e.g., "08:30").
             */
            function convertValueToTime(value) {
                const hours = Math.floor(value / 2);
                const minutes = (value % 2) * 30;
                const formattedHours = String(hours).padStart(2, '0');
                const formattedMinutes = String(minutes).padStart(2, '0');
                return `${formattedHours}:${formattedMinutes}`;
            }

            /**
             * Converts an HH:MM time string to a slider value (0-47).
             * @param {string} timeString The time string in HH:MM format.
             * @returns {number} The corresponding slider value.
             */
            function convertTimeToValue(timeString) {
                if (!timeString) return 0;
                const [hours, minutes] = timeString.split(':').map(Number);
                return (hours * 2) + (minutes / 30);
            }

            /**
             * Calculates the duration in minutes between two HH:MM time strings.
             * @param {string} startTime The start time in HH:MM format.
             * @param {string} endTime The end time in HH:MM format.
             * @returns {number} The duration in minutes.
             */
            function calculateDurationInMinutes(startTime, endTime) {
                if (!startTime || !endTime) return 0;

                const [startH, startM] = startTime.split(':').map(Number);
                const [endH, endM] = endTime.split(':').map(Number);

                const startMinutes = startH * 60 + startM;
                const endMinutes = endH * 60 + endM;

                // Assuming end time is always after start time on the same day.
                // If endMinutes is less than startMinutes, it implies crossing midnight,
                // which is not handled here for simplicity in this context.
                if (endMinutes < startMinutes) {
                    return 0;
                }

                return endMinutes - startMinutes;
            }

            // Helper for consolidating day names (e.g., Mo,Di,Mi -> Mo-Mi)
            const dayMap = { 'Mo': 0, 'Di': 1, 'Mi': 2, 'Do': 3, 'Fr': 4, 'Sa': 5, 'So': 6 };
            const daysOrder = ['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'];

            /**
             * Consolidates time ranges for display.
             * @param {Array<Object>} segments An array of time segments for a single day.
             * @returns {string} A consolidated string of time ranges (e.g., "07:30-12:30, 13:00-17:30").
             */
            function consolidateSegmentsForDisplay(segments) {
                if (!segments || segments.length === 0) {
                    return ""; // Return empty string if no segments
                }
                return segments.map(s => `${s.booking_start}-${s.booking_end}`).join(', ');
            }

            /**
             * Updates the accordion and sliders for a given day within a booking card.
             * Also updates the total hours for the entire booking card.
             * @param {HTMLElement} cardElement The parent booking card element.
             * @param {object} dayConfig The configuration object for the day (prefix, abbr).
             * @param {number} bookingIndex The index of the booking card.
             * @param {boolean} initialLoad True if this is the initial load, false for user interaction.
             */
            function updateBookingAccordionAndSliders(cardElement, dayConfig, bookingIndex, initialLoad = false) {
                const timeAccordion = cardElement.querySelector(`#${dayConfig.prefix}TimeAccordion-${bookingIndex}`);
                const dayToggleSwitch = cardElement.querySelector(`#${dayConfig.prefix}DayToggleSwitch-${bookingIndex}`);
                const mainHeading = cardElement.querySelector(`#${dayConfig.prefix}MainHeading-${bookingIndex}`);
                const segmentContainers = cardElement.querySelectorAll(`.segment-container-${dayConfig.prefix}-${bookingIndex}`);

                if (!timeAccordion || !dayToggleSwitch || !mainHeading) {
                    console.warn(`Missing core elements for day config: ${dayConfig.prefix} in card index ${bookingIndex}`);
                    return;
                }

                if (dayToggleSwitch.checked) {
                    timeAccordion.removeAttribute('disabled');
                    if (!initialLoad) {
                        timeAccordion.setAttribute('open', '');
                    }

                    let daySegmentsDisplay = [];
                    segmentContainers.forEach((segmentContainer, segmentIndex) => {
                        const startTimeSlider = segmentContainer.querySelector(`#${dayConfig.prefix}StartTimeSlider-${bookingIndex}-${segmentIndex}`);
                        const endTimeSlider = segmentContainer.querySelector(`#${dayConfig.prefix}EndTimeSlider-${bookingIndex}-${segmentIndex}`);

                        if (startTimeSlider && endTimeSlider) {
                            let startTimeValue = parseInt(startTimeSlider.value);
                            let endTimeValue = parseInt(endTimeSlider.value);

                            // Ensure end time is always greater than or equal to start time
                            if (startTimeValue > endTimeValue) {
                                endTimeSlider.value = startTimeValue;
                                endTimeValue = startTimeValue;
                            } else if (endTimeValue < startTimeValue) {
                                startTimeSlider.value = endTimeValue;
                                startTimeValue = endTimeValue;
                            }

                            const startTime = convertValueToTime(startTimeValue);
                            const endTime = convertValueToTime(endTimeValue);
                            daySegmentsDisplay.push(`${startTime}-${endTime}`);
                        }
                    });
                    mainHeading.textContent = `${dayConfig.abbr}: ${daySegmentsDisplay.join(', ')}`;
                } else {
                    timeAccordion.setAttribute('disabled', 'true');
                    timeAccordion.removeAttribute('open');
                    mainHeading.textContent = dayConfig.abbr;
                }

                updateBookingCardTotalHours(cardElement);
            }

            /**
             * Recalculates and updates the total hours displayed in a booking card's header.
             * @param {HTMLElement} cardElement The booking card element to update.
             */
            function updateBookingCardTotalHours(cardElement) {
                const bookingIndex = cardElement.dataset.bookingIndex;
                let totalBookingMinutes = 0;
                const daysConfig = [
                    { prefix: 'mo', abbr: 'Mo' },
                    { prefix: 'tu', abbr: 'Di' },
                    { prefix: 'we', abbr: 'Mi' },
                    { prefix: 'th', abbr: 'Do' },
                    { prefix: 'fr', abbr: 'Fr' }
                ];

                daysConfig.forEach(day => {
                    const dayToggleSwitch = cardElement.querySelector(`#${day.prefix}DayToggleSwitch-${bookingIndex}`);
                    if (dayToggleSwitch && dayToggleSwitch.checked) {
                        const segmentContainers = cardElement.querySelectorAll(`.segment-container-${day.prefix}-${bookingIndex}`);
                        segmentContainers.forEach(segmentContainer => {
                            const startTimeSlider = segmentContainer.querySelector(`#${day.prefix}StartTimeSlider-${bookingIndex}-${segmentContainer.dataset.segmentIndex}`);
                            const endTimeSlider = segmentContainer.querySelector(`#${day.prefix}EndTimeSlider-${bookingIndex}-${segmentContainer.dataset.segmentIndex}`);
                            if (startTimeSlider && endTimeSlider) {
                                const startTime = convertValueToTime(parseInt(startTimeSlider.value));
                                const endTime = convertValueToTime(parseInt(endTimeSlider.value));
                                totalBookingMinutes += calculateDurationInMinutes(startTime, endTime);
                            }
                        });
                    }
                });

                const totalBookingHours = (totalBookingMinutes / 60).toFixed(1);
                const headerElement = cardElement.querySelector('.booking-card-header h5');
                if (headerElement) {
                    headerElement.textContent = `Buchung ${parseInt(bookingIndex) + 1} (${totalBookingHours} h)`;
                }
            }


            /**
             * Renders the booking cards in the detail panel based on the provided booking data.
             * @param {Array<Object>} bookings An array of booking objects.
             * @param {string} itemType The type of the parent item ('demand' or 'capacity').
             */
            function renderBookingCards(bookings, itemType) {
                bookingCardsContainer.innerHTML = ''; // Clear previous cards
                console.log('Rendering booking cards for item type:', itemType, 'with bookings:', bookings); // Debugging: Check input

                const daysConfig = [
                    { prefix: 'mo', abbr: 'Mo' },
                    { prefix: 'tu', abbr: 'Di' },
                    { prefix: 'we', abbr: 'Mi' },
                    { prefix: 'th', abbr: 'Do' },
                    { prefix: 'fr', abbr: 'Fr' }
                ];

                if (!bookings || bookings.length === 0) {
                    bookingCardsContainer.innerHTML = '<p>Keine Buchungszeiten vorhanden.</p>';
                    return;
                }

                bookings.forEach((booking, index) => {
                    console.log('Processing booking:', booking); // Debugging: Individual booking object
                    const cardElement = document.createElement('div');
                    cardElement.classList.add('booking-card');
                    cardElement.dataset.bookingIndex = index; // Store index for later reference

                    // --- Calculate initial total hours for the booking ---
                    let initialTotalBookingMinutes = 0;
                    if (booking.times && booking.times.length > 0) {
                        booking.times.forEach(dayTime => { // dayTime now contains segments
                            dayTime.segments.forEach(segment => {
                                let dailyDuration = calculateDurationInMinutes(segment.booking_start, segment.booking_end);
                                initialTotalBookingMinutes += dailyDuration;
                            });
                        });
                    }
                    const initialTotalBookingHours = (initialTotalBookingMinutes / 60).toFixed(1);


                    // --- Consolidate times for display mode ---
                    let consolidatedTimesDisplay = [];
                    if (booking.times && booking.times.length > 0) {
                        booking.times.forEach(dayTime => {
                            const segmentsDisplay = consolidateSegmentsForDisplay(dayTime.segments);
                            if (segmentsDisplay) {
                                consolidatedTimesDisplay.push(`${dayTime.day_name} ${segmentsDisplay}`);
                            }
                        });
                    }
                    const consolidatedTimesHtml = consolidatedTimesDisplay.length > 0 ? consolidatedTimesDisplay.join('; ') : "Keine Zeitdaten vorhanden.";


                    // --- Format date range for display mode ---
                    let dateRangeText = '';
                    if (booking.startdate && booking.enddate) {
                        dateRangeText = `von ${booking.startdate} bis ${booking.enddate}`;
                    } else if (booking.startdate) {
                        dateRangeText = `ab ${booking.startdate}`;
                    } else if (booking.enddate) {
                        dateRangeText = `bis ${booking.enddate}`;
                    }


                    let displayModeHtml = `
                        <div class="booking-card-display-mode active">
                            <p>${dateRangeText}${dateRangeText && consolidatedTimesHtml !== 'Keine Zeitdaten vorhanden.' ? ' ' : ''}${consolidatedTimesHtml}</p>
                            ${itemType === 'capacity' && booking.times.some(dayTime => dayTime.segments.some(s => s.groupId && groupsLookup[s.groupId])) ?
                                `<p>Zugewiesene Gruppen: ${
                                    booking.times
                                        .filter(dayTime => dayTime.segments.some(s => s.groupId && groupsLookup[s.groupId]))
                                        .map(dayTime => `${dayTime.day_name}: ${
                                            dayTime.segments
                                                .filter(s => s.groupId && groupsLookup[s.groupId])
                                                .map(s => groupsLookup[s.groupId])
                                                .join(', ')
                                        }`)
                                        .join('; ')
                                }</p>`
                                : ''
                            }
                        </div>
                    `;

                    let editModeHtml = `
                        <div class="booking-card-edit-mode">
                            <div class="date-picker-group">
                                <div class="form-group">
                                    <label for="bookingStartDate${index}">Startdatum:</label>
                                    <input type="date" id="bookingStartDate${index}" class="s-input" value="${convertDDMMYYYYtoYYYYMMDD(booking.startdate || '')}">
                                </div>
                                <div class="form-group">
                                    <label for="bookingEndDate${index}">Enddatum:</label>
                                    <input type="date" id="bookingEndDate${index}" class="s-input" value="${convertDDMMYYYYtoYYYYMMDD(booking.enddate || '')}">
                                </div>
                            </div>
                            <hr style="margin: 20px 0;">
                            <h5>Tägliche Zeiten anpassen:</h5>
                    `;

                    daysConfig.forEach(day => {
                        const existingDayData = booking.times ? booking.times.find(t => t.day_name === day.abbr) : null;
                        const isChecked = !!existingDayData && existingDayData.segments.length > 0;
                        const segmentsToRender = isChecked ? existingDayData.segments : [{ booking_start: '07:00', booking_end: '17:00', groupId: '' }]; // Default segment if checked but no data

                        editModeHtml += `
                            <details id="${day.prefix}TimeAccordion-${index}" class="booking-card-details" ${isChecked ? '' : 'disabled'}>
                                <summary class="booking-card-summary">
                                    <input type="checkbox" role="switch" id="${day.prefix}DayToggleSwitch-${index}" ${isChecked ? 'checked' : ''} />
                                    <div id="${day.prefix}MainHeading-${index}">${day.abbr}: ${isChecked ? consolidateSegmentsForDisplay(segmentsToRender) : ''}</div>
                                </summary>
                                <div id="${day.prefix}SliderContainer-${index}" class="slider-container-content">
                        `;

                        segmentsToRender.forEach((segment, segmentIndex) => {
                            const startTimeValue = convertTimeToValue(segment.booking_start);
                            const endTimeValue = convertTimeToValue(segment.booking_end);
                            const currentGroupId = segment.groupId || '';

                            let groupOptionsHtml = '<option value="">Unverändert</option>';
                            if (itemType === 'capacity') {
                                for (const id in groupsLookup) {
                                    const name = groupsLookup[id];
                                    const selected = (currentGroupId === id) ? 'selected' : '';
                                    groupOptionsHtml += `<option value="${id}" ${selected}>${name}</option>`;
                                }
                            }

                            editModeHtml += `
                                <div class="segment-container-${day.prefix}-${index}" data-segment-index="${segmentIndex}">
                                    <div style="--span:6;" class="s-grid mb-4">
                                        <div class="s-col">
                                            <label>Startzeit:</label>
                                            <input type="range" id="${day.prefix}StartTimeSlider-${index}-${segmentIndex}" min="14" max="34" value="${startTimeValue}" />
                                        </div>
                                    </div>
                                    <div style="--span:6;" class="s-grid">
                                        <div class="s-col">
                                            <label>Endzeit:</label>
                                            <input type="range" id="${day.prefix}EndTimeSlider-${index}-${segmentIndex}" min="14" max="34" value="${endTimeValue}" />
                                        </div>
                                    </div>
                                    ${itemType === 'capacity' ? `
                                        <div class="group-assignment-per-day">
                                            <label for="${day.prefix}GroupSelect-${index}-${segmentIndex}">Gruppe:</label>
                                            <select id="${day.prefix}GroupSelect-${index}-${segmentIndex}" class="s-input">
                                                ${groupOptionsHtml}
                                            </select>
                                        </div>
                                    ` : ''}
                                </div>
                            `;
                        });

                        editModeHtml += `
                                </div>
                            </details>
                        `;
                    });

                    editModeHtml += `</div>`; // Close booking-card-edit-mode

                    cardElement.innerHTML = `
                        <div class="booking-card-header">
                            <h5>Buchung ${index + 1} (${initialTotalBookingHours} h)</h5>
                            <div class="booking-card-actions">
                                <i class="fas fa-edit edit-icon" title="Bearbeiten"></i>
                                <i class="fas fa-eye display-icon" title="Anzeigen" style="display: none;"></i>
                            </div>
                        </div>
                        ${displayModeHtml}
                        ${editModeHtml}
                    `;
                    bookingCardsContainer.appendChild(cardElement);

                    // Attach event listeners for this specific card
                    const editIcon = cardElement.querySelector('.edit-icon');
                    const displayIcon = cardElement.querySelector('.display-icon');
                    const displayModeDiv = cardElement.querySelector('.booking-card-display-mode');
                    const editModeDiv = cardElement.querySelector('.booking-card-edit-mode');

                    editIcon.addEventListener('click', () => {
                        displayModeDiv.classList.remove('active');
                        editModeDiv.classList.add('active');
                        editIcon.style.display = 'none';
                        displayIcon.style.display = 'inline-block';

                        // Initialize sliders and group selects when entering edit mode
                        daysConfig.forEach(day => {
                            const dayToggleSwitch = cardElement.querySelector(`#${day.prefix}DayToggleSwitch-${index}`);
                            const segmentContainers = cardElement.querySelectorAll(`.segment-container-${day.prefix}-${index}`);

                            if (dayToggleSwitch) {
                                dayToggleSwitch.onchange = () => updateBookingAccordionAndSliders(cardElement, day, index, false);
                            }

                            segmentContainers.forEach(segmentContainer => {
                                const segmentIndex = segmentContainer.dataset.segmentIndex;
                                const startTimeSlider = segmentContainer.querySelector(`#${day.prefix}StartTimeSlider-${index}-${segmentIndex}`);
                                const endTimeSlider = segmentContainer.querySelector(`#${day.prefix}EndTimeSlider-${index}-${segmentIndex}`);
                                const groupSelect = segmentContainer.querySelector(`#${day.prefix}GroupSelect-${index}-${segmentIndex}`);

                                if (startTimeSlider) {
                                    startTimeSlider.oninput = () => updateBookingAccordionAndSliders(cardElement, day, index, false);
                                }
                                if (endTimeSlider) {
                                    endTimeSlider.oninput = () => updateBookingAccordionAndSliders(cardElement, day, index, false);
                                }
                                if (itemType === 'capacity' && groupSelect) {
                                    groupSelect.onchange = () => updateBookingCardTotalHours(cardElement); // Group change doesn't affect hours
                                }
                            });

                            // Initial update for each day's accordion state based on its toggle switch
                            updateBookingAccordionAndSliders(cardElement, day, index, true);
                        });
                    });

                    displayIcon.addEventListener('click', () => {
                        editModeDiv.classList.remove('active');
                        displayModeDiv.classList.add('active');
                        displayIcon.style.display = 'none';
                        editIcon.style.display = 'inline-block';

                        // Re-render the display mode content to reflect any changes made in edit mode
                        const currentBookingData = currentSelectedItem.parseddata.booking[index];
                        let updatedConsolidatedTimesDisplay = [];
                        if (currentBookingData.times && currentBookingData.times.length > 0) {
                            currentBookingData.times.forEach(dayTime => {
                                const segmentsDisplay = consolidateSegmentsForDisplay(dayTime.segments);
                                if (segmentsDisplay) {
                                    updatedConsolidatedTimesDisplay.push(`${dayTime.day_name} ${segmentsDisplay}`);
                                }
                            });
                        }
                        const updatedConsolidatedTimesHtml = updatedConsolidatedTimesDisplay.length > 0 ? updatedConsolidatedTimesDisplay.join('; ') : "Keine Zeitdaten vorhanden.";

                        let updatedDateRangeText = '';
                        if (currentBookingData.startdate && currentBookingData.enddate) {
                            updatedDateRangeText = `von ${currentBookingData.startdate} bis ${currentBookingData.enddate}`;
                        } else if (currentBookingData.startdate) {
                            updatedDateRangeText = `ab ${currentBookingData.startdate}`;
                        } else if (currentBookingData.enddate) {
                            updatedDateRangeText = `bis ${currentBookingData.enddate}`;
                        }

                        const displayParagraph = displayModeDiv.querySelector('p:first-child');
                        if (displayParagraph) {
                            displayParagraph.innerHTML = `${updatedDateRangeText}${updatedDateRangeText && updatedConsolidatedTimesHtml !== 'Keine Zeitdaten vorhanden.' ? ' ' : ''}${updatedConsolidatedTimesHtml}`;
                        }

                        // Update group assignment display for capacity items
                        let groupDisplayP = displayModeDiv.querySelector('p:last-child');
                        const perDayGroups = currentBookingData.times
                            .filter(dayTime => dayTime.segments.some(s => s.groupId && groupsLookup[s.groupId]))
                            .map(dayTime => `${dayTime.day_name}: ${
                                dayTime.segments
                                    .filter(s => s.groupId && groupsLookup[s.groupId])
                                    .map(s => groupsLookup[s.groupId])
                                    .join(', ')
                            }`)
                            .join('; ');

                        if (itemType === 'capacity') {
                            if (perDayGroups) {
                                if (groupDisplayP && groupDisplayP.textContent.startsWith('Zugewiesene Gruppen')) {
                                    groupDisplayP.textContent = `Zugewiesene Gruppen: ${perDayGroups}`;
                                } else {
                                    const newP = document.createElement('p');
                                    newP.textContent = `Zugewiesene Gruppen: ${perDayGroups}`;
                                    displayModeDiv.appendChild(newP);
                                }
                            } else {
                                if (groupDisplayP && groupDisplayP.textContent.startsWith('Zugewiesene Gruppen')) {
                                    groupDisplayP.remove();
                                }
                            }
                        }
                    });

                    // Initial state: display mode active
                    displayModeDiv.classList.add('active');
                });
            }

            /**
             * Renders the group cards in the detail panel based on the provided group data.
             * @param {Array<Object>} groups An array of group objects.
             */
            function renderGroupCards(groups) {
                groupCardsContainer.innerHTML = ''; // Clear previous cards

                if (!groups || groups.length === 0) {
                    groupCardsContainer.innerHTML = '<p>Keine Gruppenzuordnungen vorhanden.</p>';
                    return;
                }

                groups.forEach((group, index) => {
                    const cardElement = document.createElement('div');
                    cardElement.classList.add('group-card');
                    cardElement.dataset.groupIndex = index; // Store index for later reference

                    // --- Format date range for display mode ---
                    let dateRangeText = '';
                    if (group.start && group.end) {
                        dateRangeText = `von ${group.start} bis ${group.end}`;
                    } else if (group.start) {
                        dateRangeText = `ab ${group.start}`;
                    } else if (group.end) {
                        dateRangeText = `bis ${group.end}`;
                    }

                    let displayModeHtml = `
                        <div class="group-card-display-mode active">
                            <p>${dateRangeText}</p>
                        </div>
                    `;

                    // Create options for the dropdown
                    let groupOptionsHtml = '';
                    for (const id in groupsLookup) {
                        const name = groupsLookup[id];
                        const selected = (parseInt(id) === group.id) ? 'selected' : '';
                        groupOptionsHtml += `<option value="${id}" ${selected}>${name}</option>`;
                    }


                    let editModeHtml = `
                        <div class="group-card-edit-mode">
                            <div class="form-group">
                                <label for="groupNameSelect${index}">Gruppenname:</label>
                                <select id="groupNameSelect${index}" class="s-input">
                                    ${groupOptionsHtml}
                                </select>
                            </div>
                            <div class="date-picker-group">
                                <div class="form-group">
                                    <label for="groupStartDate${index}">Startdatum:</label>
                                    <input type="date" id="groupStartDate${index}" class="s-input" value="${convertDDMMYYYYtoYYYYMMDD(group.start || '')}">
                                </div>
                                <div class="form-group">
                                    <label for="groupEndDate${index}">Enddatum:</label>
                                    <input type="date" id="groupEndDate${index}" class="s-input" value="${convertDDMMYYYYtoYYYYMMDD(group.end || '')}">
                                </div>
                            </div>
                        </div>
                    `;

                    cardElement.innerHTML = `
                        <div class="group-card-header">
                            <h5>${group.name}</h5>
                            <div class="group-card-actions">
                                <i class="fas fa-edit edit-icon" title="Bearbeiten"></i>
                                <i class="fas fa-eye display-icon" title="Anzeigen" style="display: none;"></i>
                            </div>
                        </div>
                        ${displayModeHtml}
                        ${editModeHtml}
                    `;
                    groupCardsContainer.appendChild(cardElement);

                    // Attach event listeners for this specific card
                    const editIcon = cardElement.querySelector('.edit-icon');
                    const displayIcon = cardElement.querySelector('.display-icon');
                    const displayModeDiv = cardElement.querySelector('.group-card-display-mode');
                    const editModeDiv = cardElement.querySelector('.group-card-edit-mode');
                    const groupNameHeading = cardElement.querySelector('.group-card-header h5');
                    const groupNameSelect = cardElement.querySelector(`#groupNameSelect${index}`);

                    editIcon.addEventListener('click', () => {
                        displayModeDiv.classList.remove('active');
                        editModeDiv.classList.add('active');
                        editIcon.style.display = 'none';
                        displayIcon.style.display = 'inline-block';
                    });

                    displayIcon.addEventListener('click', () => {
                        editModeDiv.classList.remove('active');
                        displayModeDiv.classList.add('active');
                        displayIcon.style.display = 'none';
                        editIcon.style.display = 'inline-block';

                        // Update the display mode heading with the selected group name
                        if (groupNameSelect) {
                            groupNameHeading.textContent = groupNameSelect.options[groupNameSelect.selectedIndex].text;
                        }
                    });

                    // Initial state: display mode active
                    displayModeDiv.classList.add('active');
                });
            }

            /**
             * Removes all 'modified' classes from elements within the detail panel.
             */
            function clearModificationsVisuals() {
                document.querySelectorAll('.modified-input, .modified-checkbox + div, .modified-select, .modified-card').forEach(el => {
                    el.classList.remove('modified-input', 'modified-checkbox', 'modified-select', 'modified-card');
                });
            }

            /**
             * Applies 'modified' classes to elements based on the currentSelectedItem.modifications.
             */
            function applyModificationsVisuals() {
                clearModificationsVisuals(); // Clear previous highlights first

                if (!currentSelectedItem || !currentSelectedItem.modifications) {
                    console.log('No currentSelectedItem or modifications to apply visuals.');
                    return;
                }
                console.log('Applying visuals for modifications:', currentSelectedItem.modifications);

                currentSelectedItem.modifications.forEach(mod => {
                    let targetElement = null;
                    let cardElement = null; // To mark the parent card as modified

                    switch (mod.type) {
                        case 'main_date_change':
                            // Corrected ID generation for main dates
                            let idPart = '';
                            if (mod.field === 'startdate') {
                                idPart = 'StartDate';
                            } else if (mod.field === 'enddate') {
                                idPart = 'EndDate';
                            }
                            targetElement = document.getElementById(`detail${idPart}`);
                            console.log(`Mod Type: ${mod.type}, Field: ${mod.field}, Target ID: detail${idPart}`, 'Target Element:', targetElement);
                            if (targetElement) targetElement.classList.add('modified-input');
                            break;
                        case 'booking_card_date_change':
                            targetElement = document.getElementById(`booking${mod.field.charAt(0).toUpperCase() + mod.field.slice(1)}${mod.booking_index}`);
                            console.log(`Mod Type: ${mod.type}, Field: ${mod.field}, Booking Index: ${mod.booking_index}, Target ID: booking${mod.field.charAt(0).toUpperCase() + mod.field.slice(1)}${mod.booking_index}`, 'Target Element:', targetElement);
                            if (targetElement) targetElement.classList.add('modified-input');
                            cardElement = bookingCardsContainer.querySelector(`.booking-card[data-booking-index="${mod.booking_index}"]`);
                            break;
                        case 'booking_day_toggle':
                            targetElement = document.getElementById(`${mod.day_name.toLowerCase()}DayToggleSwitch-${mod.booking_index}`);
                            console.log(`Mod Type: ${mod.type}, Day: ${mod.day_name}, Booking Index: ${mod.booking_index}, Target ID: ${mod.day_name.toLowerCase()}DayToggleSwitch-${mod.booking_index}`, 'Target Element:', targetElement);
                            if (targetElement) targetElement.classList.add('modified-checkbox');
                            cardElement = bookingCardsContainer.querySelector(`.booking-card[data-booking-index="${mod.booking_index}"]`);
                            break;
                        case 'booking_segment_time_change':
                            const timeField = mod.field.replace('booking_', '');
                            targetElement = document.getElementById(`${mod.day_name.toLowerCase()}${timeField.charAt(0).toUpperCase() + timeField.slice(1)}Slider-${mod.booking_index}-${mod.segment_index}`);
                            console.log(`Mod Type: ${mod.type}, Field: ${mod.field}, Day: ${mod.day_name}, Booking Index: ${mod.booking_index}, Segment Index: ${mod.segment_index}, Target ID: ${mod.day_name.toLowerCase()}${timeField.charAt(0).toUpperCase() + timeField.slice(1)}Slider-${mod.booking_index}-${mod.segment_index}`, 'Target Element:', targetElement);
                            if (targetElement) targetElement.classList.add('modified-input');
                            cardElement = bookingCardsContainer.querySelector(`.booking-card[data-booking-index="${mod.booking_index}"]`);
                            break;
                        case 'booking_segment_group_assign':
                            targetElement = document.getElementById(`${mod.day_name.toLowerCase()}GroupSelect-${mod.booking_index}-${mod.segment_index}`);
                            console.log(`Mod Type: ${mod.type}, Field: ${mod.field}, Day: ${mod.day_name}, Booking Index: ${mod.booking_index}, Segment Index: ${mod.segment_index}, Target ID: ${mod.day_name.toLowerCase()}GroupSelect-${mod.booking_index}-${mod.segment_index}`, 'Target Element:', targetElement);
                            if (targetElement) targetElement.classList.add('modified-select');
                            cardElement = bookingCardsContainer.querySelector(`.booking-card[data-booking-index="${mod.booking_index}"]`);
                            break;
                        case 'group_card_detail_change':
                            if (mod.field === 'id') {
                                targetElement = document.getElementById(`groupNameSelect${mod.group_index}`); // Corrected: use mod.group_index
                                console.log(`Mod Type: ${mod.type}, Field: ${mod.field}, Group Index: ${mod.group_index}, Target ID: groupNameSelect${mod.group_index}`, 'Target Element:', targetElement);
                                if (targetElement) targetElement.classList.add('modified-select');
                            } else {
                                const dateField = mod.field.charAt(0).toUpperCase() + mod.field.slice(1);
                                targetElement = document.getElementById(`group${dateField}Date${mod.group_index}`); // Corrected: use mod.group_index
                                console.log(`Mod Type: ${mod.type}, Field: ${mod.field}, Group Index: ${mod.group_index}, Target ID: group${dateField}Date${mod.group_index}`, 'Target Element:', targetElement);
                                if (targetElement) targetElement.classList.add('modified-input');
                            }
                            cardElement = groupCardsContainer.querySelector(`.group-card[data-group-index="${mod.group_index}"]`); // Corrected: use mod.group_index
                            break;
                    }

                    if (cardElement) {
                        console.log(`Marking card ${cardElement.dataset.groupIndex || cardElement.dataset.bookingIndex} as modified.`);
                        cardElement.classList.add('modified-card');
                    }
                });
            }


            /**
             * Displays the detail panel with data for the selected item.
             * @param {object} item The data item to display.
             */
            function showDetailPanel(item) {
                currentSelectedItem = item; // Store the item for potential saving
                rawdataContent.textContent = JSON.stringify(item.rawdata, null, 2);
                parseddataContent.textContent = JSON.stringify(item.parseddata, null, 2); // Display parsed data
                modificationsContent.textContent = JSON.stringify(item.modifications || [], null, 2); // Display modifications

                detailPanelTitle.textContent = `Details für: ${item.name}`;

                // Populate main date pickers in the "Daten" tab of the detail panel
                detailStartDateInput.value = convertDDMMYYYYtoYYYYMMDD(item.parseddata.startdate);
                detailEndDateInput.value = convertDDMMYYYYtoYYYYMMDD(item.parseddata.enddate);
                hideDetailMessage(); // Hide any previous messages in the detail form

                // Render booking cards, passing the item type
                if (item.parseddata.booking) { // Ensure booking data exists
                    renderBookingCards(item.parseddata.booking, item.type);
                } else {
                    bookingCardsContainer.innerHTML = '<p>Keine Buchungszeiten vorhanden.</p>';
                }

                // Render group cards
                if (item.parseddata.group) { // Ensure group data exists
                    renderGroupCards(item.parseddata.group);
                } else {
                    groupCardsContainer.innerHTML = '<p>Keine Gruppenzuordnungen vorhanden.</p>';
                }

                detailPanel.classList.add('open');
                adjustDetailPanelPosition();

                // Apply visual modifications after rendering all elements
                applyModificationsVisuals();

                // Reset detail tabs to "Daten" when opening a new detail panel
                detailNavItems.forEach(nav => nav.classList.remove('active'));
                detailTabPanes.forEach(pane => pane.classList.remove('active'));
                document.querySelector('.detail-nav-item[data-detail-tab="parsedDataTab"]').classList.add('active');
                document.getElementById('parsedDataTab').classList.add('active');
            }

            /**
             * Displays data in the main table.
             * @param {Array<Object>} data The array of data items to display.
             */
            function displayDataTable(data) {
                dataTableBody.innerHTML = '';

                if (data.length === 0) {
                    const noDataRow = dataTableBody.insertRow();
                    noDataRow.classList.add('no-data-row');
                    const cell = noDataRow.insertCell();
                    cell.colSpan = 5;
                    cell.textContent = 'Keine Daten geladen. Bitte importieren Sie eine Datei.';
                } else {
                    data.forEach(item => {
                        // Corrected: insert a row first, then cells into that row
                        const row = dataTableBody.insertRow();
                        row.dataset.id = item.id;
                        row.dataset.type = item.type;
                        row.dataset.originalId = item.rawdata.data.KIND ? item.rawdata.data.KIND.KINDNR : item.rawdata.data.ANSTELLUNG.IDNR;

                        row.insertCell().textContent = item.type === 'demand' ? 'Kind' : 'Mitarbeiter';
                        row.insertCell().textContent = item.name;
                        row.insertCell().textContent = item.parseddata.startdate || '';
                        row.insertCell().textContent = item.parseddata.enddate || '';
                        row.insertCell().textContent = item.rawdata.source || '';

                        row.addEventListener('click', (event) => {
                            event.stopPropagation(); // Prevent click on row from propagating to window

                            const clickedRowId = row.dataset.originalId;

                            if (detailPanel.classList.contains('open') && currentSelectedRowId === clickedRowId) {
                                // If panel is open and same row is clicked, close it
                                detailPanel.classList.remove('open');
                                row.classList.remove('selected');
                                currentSelectedRowId = null;
                            } else {
                                // Remove 'selected' class from previously selected row
                                const currentSelected = document.querySelector('.data-table tbody tr.selected');
                                if (currentSelected) {
                                    currentSelected.classList.remove('selected');
                                }
                                // Add 'selected' class to the clicked row
                                row.classList.add('selected');
                                currentSelectedRowId = clickedRowId;
                                showDetailPanel(item);
                            }
                        });
                    });
                }
            }


            // --- Event Listeners and Initial Calls ---

            // Event listener for the "Import" icon
            if (importIcon) {
                importIcon.addEventListener('click', () => {
                    console.log('Import icon clicked!'); // Debugging: Check if click listener fires
                    if (uploadModal) {
                        uploadModal.style.display = 'flex';
                        hideMessage();
                    } else {
                        console.error('Upload modal element not found!');
                    }
                });
            } else {
                console.error('Import icon element not found!');
            }

            // Event listener for closing the modal
            if (closeModalBtn) {
                closeModalBtn.addEventListener('click', () => {
                    console.log('Close modal button clicked!'); // Debugging: Check if close button click fires
                    if (uploadModal) {
                        uploadModal.style.display = 'none';
                    }
                });
            } else {
                console.error('Close modal button element not found!');
            }

            // Close modal or detail panel if user clicks outside of them
            window.addEventListener('click', (event) => {
                if (event.target == uploadModal) {
                    console.log('Clicked outside upload modal!');
                    uploadModal.style.display = 'none';
                }

                // Close detail panel if clicked outside
                if (detailPanel.classList.contains('open')) {
                    const clickedElement = event.target;
                    const isClickInsideDetailPanel = detailPanel.contains(clickedElement);
                    const isClickOnTableRow = clickedElement.closest('#dataTable tbody tr');

                    if (!isClickInsideDetailPanel && !isClickOnTableRow) {
                        detailPanel.classList.remove('open');
                        const currentSelected = document.querySelector('.data-table tbody tr.selected');
                        if (currentSelected) {
                            currentSelected.classList.remove('selected');
                        }
                        currentSelectedRowId = null;
                    }
                }
            });


            uploadButton.addEventListener('click', async () => {
                hideMessage();
                const file = zipFileInput.files[0];

                if (!file) {
                    showMessage('Bitte wählen Sie eine ZIP-Datei aus.');
                    return;
                }
                if (file.type !== 'application/zip' && !file.name.endsWith('.zip')) {
                    showMessage('Ungültiger Dateityp. Bitte laden Sie eine ZIP-Datei hoch.');
                    return;
                }

                showLoading();
                processedData = [];
                groupsLookup = {}; // Clear previous lookup

                try {
                    const zip = await JSZip.loadAsync(file);
                    const xmlContents = {};

                    // Read and decode XML files
                    for (const fileName of ['kind.xml', 'gruki.xml', 'gruppe.xml', 'belegung.xml', 'anstell.xml']) {
                        const zipEntry = zip.file(fileName);
                        if (zipEntry) {
                            // Use TextDecoder for Windows-1252
                            const decoder = new TextDecoder('windows-1252');
                            const arrayBuffer = await zipEntry.async("arraybuffer");
                            xmlContents[fileName] = decoder.decode(arrayBuffer);
                        } else {
                            showMessage(`Warnung: Datei ${fileName} wurde im ZIP nicht gefunden.`, 'warning');
                        }
                    }

                    // Parse XML DOMs
                    const kindXmlDoc = xmlContents['kind.xml'] ? parseXmlString(xmlContents['kind.xml']) : null;
                    const grukiXmlDoc = xmlContents['gruki.xml'] ? parseXmlString(xmlContents['gruki.xml']) : null;
                    const gruppeXmlDoc = xmlContents['gruppe.xml'] ? parseXmlString(xmlContents['gruppe.xml']) : null;
                    const belegungXmlDoc = xmlContents['belegung.xml'] ? parseXmlString(xmlContents['belegung.xml']) : null;
                    const anstellXmlDoc = xmlContents['anstell.xml'] ? parseXmlString(xmlContents['anstell.xml']) : null;

                    const anonymize = anonymizeCheckbox.checked;

                    // --- Process Gruppen (Groups) first for lookup ---
                    if (gruppeXmlDoc) {
                        gruppeXmlDoc.querySelectorAll('GRUPPE').forEach(groupEl => {
                            const grunr = getXmlValue(groupEl, 'GRUNR');
                            const bez = getXmlValue(groupEl, 'BEZ');
                            if (grunr) {
                                groupsLookup[grunr] = bez;
                            }
                        });
                    }

                    // --- Process Kinder (Demand) ---
                    if (kindXmlDoc) {
                        let idCounter = 1;
                        kindXmlDoc.querySelectorAll('KIND').forEach(kindEl => {
                            const austrdat = getXmlValue(kindEl, 'AUSTRDAT');
                            if (isFutureOrEmptyDate(austrdat)) {
                                const kindNr = getXmlValue(kindEl, 'KINDNR');
                                const fname = getXmlValue(kindEl, 'FNAME');
                                const aufnDat = getXmlValue(kindEl, 'AUFNDAT');

                                const kindData = {
                                    KINDNR: kindNr,
                                    AUFNDAT: aufnDat,
                                    AUSTRDAT: austrdat,
                                    GRUNR: getXmlValue(kindEl, 'GRUNR'),
                                    GEBDATUM: getXmlValue(kindEl, 'GEBDATUM'),
                                    FNAME: anonymize ? '' : fname // Anonymize FNAME in rawdata
                                };

                                const currentGruki = [];
                                if (grukiXmlDoc) {
                                    grukiXmlDoc.querySelectorAll('GRUPPENZUORDNUNG').forEach(grukiEl => {
                                        if (getXmlValue(grukiEl, 'KINDNR') === kindNr) {
                                            const gkbis = getXmlValue(grukiEl, 'GKBIS');
                                            if (isFutureOrEmptyDate(gkbis)) {
                                                currentGruki.push({
                                                    KINDNR: getXmlValue(grukiEl, 'KINDNR'),
                                                    GRUNR: getXmlValue(grukiEl, 'GRUNR'),
                                                    GKVON: getXmlValue(grukiEl, 'GKVON'),
                                                    GKBIS: gkbis
                                                });
                                            }
                                        }
                                    });
                                }

                                const currentBelegungen = [];
                                if (belegungXmlDoc) {
                                    belegungXmlDoc.querySelectorAll('BELEGUNGSBUCHUNG').forEach(belegungEl => {
                                        if (getXmlValue(belegungEl, 'KINDNR') === kindNr) {
                                            const belbis = getXmlValue(belegungEl, 'BELBIS');
                                            if (isFutureOrEmptyDate(belbis)) {
                                                currentBelegungen.push({
                                                    IDNR: getXmlValue(belegungEl, 'IDNR'),
                                                    KINDNR: getXmlValue(belegungEl, 'KINDNR'),
                                                    BELVON: getXmlValue(belegungEl, 'BELVON'),
                                                    BELBIS: belbis,
                                                    ZEITEN: getXmlValue(belegungEl, 'ZEITEN')
                                                });
                                            }
                                        }
                                    });
                                }

                                const parsedGroups = currentGruki.map(g => ({
                                    id: parseInt(g.GRUNR),
                                    name: groupsLookup[g.GRUNR] || `Gruppe ${g.GRUNR}`, // Use lookup
                                    start: g.GKVON,
                                    end: g.GKBIS
                                }));

                                const parsedBookings = currentBelegungen.map(b => ({
                                    startdate: b.BELVON,
                                    enddate: b.BELBIS,
                                    times: parseZeiten(b.ZEITEN) // This now returns array of {day, day_name, segments: []}
                                }));

                                processedData.push({
                                    id: idCounter++,
                                    type: "demand",
                                    name: anonymize ? `Kind ${kindNr}` : fname,
                                    rawdata: {
                                        source: "adebis export",
                                        data: {
                                            KIND: kindData,
                                            GRUPPENZUORDNUNG: currentGruki.length > 0 ? currentGruki : undefined,
                                            BELEGUNGSBUCHUNG: currentBelegungen.length > 0 ? currentBelegungen : undefined
                                        }
                                    },
                                    parseddata: {
                                        startdate: aufnDat,
                                        enddate: austrdat,
                                        group: parsedGroups,
                                        booking: parsedBookings
                                    },
                                    originalParsedData: JSON.parse(JSON.stringify({ // Store original parsed data
                                        startdate: aufnDat,
                                        enddate: austrdat,
                                        group: parsedGroups,
                                        booking: parsedBookings
                                    })),
                                    modifications: [], // Initialize modifications array
                                    modifiers: {
                                        _comment: "future functions"
                                    },
                                    simudata: {
                                        _comment: "future functions"
                                    }
                                });
                            }
                        });
                    }

                    // --- Process Angestellte (Capacity) ---
                    if (anstellXmlDoc) {
                        let idCounter = 1;
                        anstellXmlDoc.querySelectorAll('ANSTELLUNG').forEach(anstellEl => {
                            const endDat = getXmlValue(anstellEl, 'ENDDAT');
                            if (isFutureOrEmptyDate(endDat)) {
                                const idNr = getXmlValue(anstellEl, 'IDNR');
                                const beginnDat = getXmlValue(anstellEl, 'BEGINNDAT');
                                const arbZeit = getXmlValue(anstellEl, 'ARBZEIT');
                                const urlaub = getXmlValue(anstellEl, 'URLAUB');
                                const qualifik = getXmlValue(anstellEl, 'QUALIFIK');
                                const vertragArt = getXmlValue(anstellEl, 'VERTRAGART');
                                const zeiten = getXmlValue(anstellEl, 'ZEITEN');

                                const initialBookingTimes = parseZeiten(zeiten).map(dayTime => ({
                                    ...dayTime,
                                    segments: dayTime.segments.map(segment => ({ ...segment, groupId: '' }))
                                }));

                                processedData.push({
                                    id: idCounter++,
                                    type: "capacity",
                                    name: `Mitarbeiter ${idNr}`,
                                    rawdata: {
                                        source: "adebis export",
                                        data: {
                                            ANSTELLUNG: {
                                                IDNR: idNr,
                                                BEGINNDAT: beginnDat,
                                                ENDDAT: endDat,
                                                ARBZEIT: arbZeit,
                                                URLAUB: urlaub,
                                                QUALIFIK: qualifik,
                                                VERTRAGART: vertragArt,
                                                ZEITEN: zeiten
                                            }
                                        }
                                    },
                                    parseddata: {
                                        startdate: beginnDat,
                                        enddate: endDat,
                                        qualification: qualifik,
                                        vacation: urlaub,
                                        worktime: arbZeit,
                                        booking: [{
                                            startdate: beginnDat,
                                            enddate: endDat,
                                            times: initialBookingTimes
                                        }],
                                        group: [] // Employees don't have group assignments in this context
                                    },
                                    originalParsedData: JSON.parse(JSON.stringify({ // Store original parsed data
                                        startdate: beginnDat,
                                        enddate: endDat,
                                        qualification: qualifik,
                                        vacation: urlaub,
                                        worktime: arbZeit,
                                        booking: [{
                                            startdate: beginnDat,
                                            enddate: endDat,
                                            times: initialBookingTimes
                                        }],
                                        group: []
                                    })),
                                    modifications: [], // Initialize modifications array
                                    modifiers: {
                                        _comment: "future functions"
                                    },
                                    simudata: {
                                        _comment: "future functions"
                                    }
                                });
                            }
                        });
                    }

                    displayDataTable(processedData);
                    uploadModal.style.display = 'none';
                    showMessage(`Erfolgreich ${processedData.length} Datensätze verarbeitet.`, 'success');

                } catch (error) {
                    console.error('Fehler beim Verarbeiten der Datei:', error);
                    showMessage(`Fehler beim Verarbeiten der Datei: ${error.message}`);
                } finally {
                    hideLoading();
                }
            });

            // Event listener for the save button in the detail form's "Daten" tab
            saveDetailDatesButton.addEventListener('click', () => {
                const tempModifications = [];
                const now = new Date().toISOString();

                // Capture original parseddata for comparison
                const originalParsedDataRef = currentSelectedItem.originalParsedData;
                const currentParsedDataRef = currentSelectedItem.parseddata;


                // Helper to add or remove modification
                function addOrUpdateModification(uniqueId, type, field, originalValue, modifiedValue, bookingIndex, dayName, segmentIndex, oldGroupId, newGroupId, oldGroupName, newGroupName) {
                    let val1 = originalValue;
                    let val2 = modifiedValue;

                    // Special handling for group ID which is stored as int
                    if (field === 'id' && typeof val1 === 'number' && typeof val2 === 'string') {
                        val2 = parseInt(val2);
                    }

                    if (val1 !== val2) { // Direct comparison for most types
                        tempModifications.push({
                            uniqueId: uniqueId,
                            type: type,
                            field: field,
                            original_value: originalValue,
                            modified_value: modifiedValue,
                            timestamp: now,
                            ...(typeof bookingIndex !== 'undefined' && { booking_index: bookingIndex }),
                            ...(dayName && { day_name: dayName }),
                            ...(typeof segmentIndex !== 'undefined' && { segment_index: segmentIndex }),
                            ...(typeof oldGroupId !== 'undefined' && { old_group_id: oldGroupId }),
                            ...(typeof newGroupId !== 'undefined' && { new_group_id: newGroupId }),
                            ...(oldGroupName && { old_group_name: oldGroupName }),
                            ...(newGroupName && { new_group_name: newGroupName })
                        });
                    }
                }


                // --- Compare and update Main Dates ---
                const newDetailStartDate = detailStartDateInput.value; // YYYY-MM-DD from input
                const newDetailEndDate = detailEndDateInput.value;   // YYYY-MM-DD from input

                // Basic validation for main dates
                if (!newDetailStartDate || !newDetailEndDate) {
                    showDetailMessage('Bitte wählen Sie sowohl ein Start- als auch ein Enddatum für das Hauptobjekt aus.', 'error');
                    return;
                }
                if (new Date(newDetailStartDate) > new Date(newDetailEndDate)) {
                    showDetailMessage('Das Startdatum des Hauptobjekts darf nicht nach dem Enddatum liegen.', 'error');
                    return;
                }

                // Convert input dates to DD.MM.YYYY for comparison with originalParsedDataRef
                const convertedNewDetailStartDate = convertYYYYMMDDtoDDMMYYYY(newDetailStartDate);
                const convertedNewDetailEndDate = convertYYYYMMDDtoDDMMYYYY(newDetailEndDate);

                console.log('Main Dates Comparison:');
                console.log('Original Start Date (DD.MM.YYYY):', originalParsedDataRef.startdate);
                console.log('New Start Date (DD.MM.YYYY):', convertedNewDetailStartDate);
                console.log('Original End Date (DD.MM.YYYY):', originalParsedDataRef.enddate);
                console.log('New End Date (DD.MM.YYYY):', convertedNewDetailEndDate);

                addOrUpdateModification(
                    "main_startdate", "main_date_change", "startdate",
                    originalParsedDataRef.startdate, convertedNewDetailStartDate
                );
                addOrUpdateModification(
                    "main_enddate", "main_date_change", "enddate",
                    originalParsedDataRef.enddate, convertedNewDetailEndDate
                );

                // Update current parsed data for main dates
                currentParsedDataRef.startdate = convertedNewDetailStartDate;
                currentParsedDataRef.enddate = convertedNewDetailEndDate;


                // --- Collect and update Booking Card Data ---
                const updatedBookings = [];
                const bookingCardElements = bookingCardsContainer.querySelectorAll('.booking-card');
                const daysConfig = [
                    { prefix: 'mo', abbr: 'Mo' },
                    { prefix: 'tu', abbr: 'Di' },
                    { prefix: 'we', abbr: 'Mi' },
                    { prefix: 'th', abbr: 'Do' },
                    { prefix: 'fr', abbr: 'Fr' }
                ];

                bookingCardElements.forEach((cardElement, bookingIndex) => {
                    const bookingStartDateInput = cardElement.querySelector(`#bookingStartDate${bookingIndex}`);
                    const bookingEndDateInput = cardElement.querySelector(`#bookingEndDate${bookingIndex}`);

                    const originalBooking = originalParsedDataRef.booking[bookingIndex] || { times: [] };
                    const newBookingStartDate = convertYYYYMMDDtoDDMMYYYY(bookingStartDateInput.value);
                    const newBookingEndDate = convertYYYYMMDDtoDDMMYYYY(bookingEndDateInput.value);

                    addOrUpdateModification(
                        `booking_${bookingIndex}_startdate`, "booking_card_date_change", "startdate",
                        originalBooking.startdate, newBookingStartDate, bookingIndex
                    );
                    addOrUpdateModification(
                        `booking_${bookingIndex}_enddate`, "booking_card_date_change", "enddate",
                        originalBooking.enddate, newBookingEndDate, bookingIndex
                    );

                    const updatedDayTimes = [];
                    daysConfig.forEach(day => {
                        const dayToggleSwitch = cardElement.querySelector(`#${day.prefix}DayToggleSwitch-${bookingIndex}`);
                        const originalDayData = originalBooking.times ? originalBooking.times.find(t => t.day_name === day.abbr) : null;
                        const originalIsChecked = !!originalDayData && originalDayData.segments.length > 0;

                        if (dayToggleSwitch) {
                            if (dayToggleSwitch.checked !== originalIsChecked) {
                                addOrUpdateModification(
                                    `booking_${bookingIndex}_${day.prefix}_toggle`, "booking_day_toggle", "day_toggle",
                                    originalIsChecked, dayToggleSwitch.checked, bookingIndex, day.abbr
                                );
                            }

                            if (dayToggleSwitch.checked) {
                                const segmentsForDay = [];
                                const segmentContainers = cardElement.querySelectorAll(`.segment-container-${day.prefix}-${bookingIndex}`);

                                segmentContainers.forEach((segmentContainer, segmentIndex) => {
                                    const startTimeSlider = segmentContainer.querySelector(`#${day.prefix}StartTimeSlider-${bookingIndex}-${segmentIndex}`);
                                    const endTimeSlider = segmentContainer.querySelector(`#${day.prefix}EndTimeSlider-${bookingIndex}-${segmentIndex}`);
                                    const groupSelect = segmentContainer.querySelector(`#${day.prefix}GroupSelect-${bookingIndex}-${segmentIndex}`);

                                    const originalSegment = originalDayData && originalDayData.segments ? originalDayData.segments[segmentIndex] : {};

                                    if (startTimeSlider && endTimeSlider) {
                                        const newBookingStart = convertValueToTime(parseInt(startTimeSlider.value));
                                        const newBookingEnd = convertValueToTime(parseInt(endTimeSlider.value));

                                        addOrUpdateModification(
                                            `booking_${bookingIndex}_${day.prefix}_segment_${segmentIndex}_start`, "booking_segment_time_change", "booking_start",
                                            originalSegment.booking_start, newBookingStart, bookingIndex, day.abbr, segmentIndex
                                        );
                                        addOrUpdateModification(
                                            `booking_${bookingIndex}_${day.prefix}_segment_${segmentIndex}_end`, "booking_segment_time_change", "booking_end",
                                            originalSegment.booking_end, newBookingEnd, bookingIndex, day.abbr, segmentIndex
                                        );

                                        const segment = {
                                            booking_start: newBookingStart,
                                            booking_end: newBookingEnd
                                        };

                                        if (currentSelectedItem.type === 'capacity' && groupSelect) {
                                            const newGroupId = groupSelect.value;
                                            const originalGroupId = originalSegment.groupId || '';
                                            if (originalGroupId !== newGroupId) {
                                                addOrUpdateModification(
                                                    `booking_${bookingIndex}_${day.prefix}_segment_${segmentIndex}_group`, "booking_segment_group_assign", "groupId",
                                                    originalGroupId, newGroupId, bookingIndex, day.abbr, segmentIndex,
                                                    originalGroupId, newGroupId, groupsLookup[originalGroupId], groupsLookup[newGroupId]
                                                );
                                            }
                                            segment.groupId = newGroupId;
                                        }
                                        segmentsForDay.push(segment);
                                    }
                                });

                                if (segmentsForDay.length > 0) {
                                    updatedDayTimes.push({
                                        day: daysConfig.findIndex(d => d.abbr === day.abbr) + 1,
                                        day_name: day.abbr,
                                        segments: segmentsForDay
                                    });
                                }
                            }
                        }
                    });

                    updatedBookings.push({
                        startdate: newBookingStartDate,
                        enddate: newBookingEndDate,
                        times: updatedDayTimes
                    });
                });
                currentParsedDataRef.booking = updatedBookings;


                // --- Collect and update Group Card Data ---
                const updatedGroups = [];
                const groupCardElements = groupCardsContainer.querySelectorAll('.group-card');
                groupCardElements.forEach((cardElement, groupIndex) => {
                    const groupStartDateInput = cardElement.querySelector(`#groupStartDate${groupIndex}`);
                    const groupEndDateInput = cardElement.querySelector(`#groupEndDate${groupIndex}`);
                    const groupNameSelect = cardElement.querySelector(`#groupNameSelect${groupIndex}`);

                    const originalGroup = originalParsedDataRef.group[groupIndex] || {};

                    const newGroupStartDate = convertYYYYMMDDtoDDMMYYYY(groupStartDateInput.value);
                    const newGroupEndDate = convertYYYYMMDDtoDDMMYYYY(groupEndDateInput.value);
                    const newGroupId = groupNameSelect ? groupNameSelect.value : '';

                    // Explicitly pass groupIndex for group card modifications
                    addOrUpdateModification(
                        `group_${groupIndex}_id`, "group_card_detail_change", "id",
                        originalGroup.id, parseInt(newGroupId), groupIndex, undefined, undefined, // Pass groupIndex here
                        originalGroup.id, newGroupId, groupsLookup[originalGroup.id], groupsLookup[newGroupId]
                    );
                    addOrUpdateModification(
                        `group_${groupIndex}_start`, "group_card_detail_change", "start",
                        originalGroup.start, newGroupStartDate, groupIndex // Pass groupIndex here
                    );
                    addOrUpdateModification(
                        `group_${groupIndex}_end`, "group_card_detail_change", "end",
                        originalGroup.end, newGroupEndDate, groupIndex // Pass groupIndex here
                    );

                    updatedGroups.push({
                        id: parseInt(newGroupId),
                        name: groupsLookup[newGroupId] || `Gruppe ${newGroupId}`,
                        start: newGroupStartDate,
                        end: newGroupEndDate
                    });
                });
                currentParsedDataRef.group = updatedGroups;

                // Update the modifications array in currentSelectedItem
                currentSelectedItem.modifications = tempModifications;


                // Find the item in the main processedData array and update it
                const itemIndex = processedData.findIndex(item => item.id === currentSelectedItem.id);
                if (itemIndex !== -1) {
                    processedData[itemIndex] = currentSelectedItem;
                    // Re-render the main data table to reflect updated dates
                    displayDataTable(processedData);
                }

                showDetailMessage(`Daten für ${currentSelectedItem.name} erfolgreich gespeichert.`, 'success');
                console.log('Updated item:', currentSelectedItem);
                console.log('CurrentSelectedItem modifications after save:', currentSelectedItem.modifications); // Added this

                // Re-render detail panel to show new modifications and apply visuals
                showDetailPanel(currentSelectedItem);
            });

            // Event listener for the new Reset button
            resetDetailButton.addEventListener('click', () => {
                if (!currentSelectedItem) {
                    showDetailMessage('Kein Element zum Zurücksetzen ausgewählt.', 'error');
                    return;
                }

                // Deep copy originalParsedData back to parseddata
                currentSelectedItem.parseddata = JSON.parse(JSON.stringify(currentSelectedItem.originalParsedData));
                currentSelectedItem.modifications = []; // Clear all modifications

                // Re-render the detail panel to reflect original values and clear visuals
                showDetailPanel(currentSelectedItem);

                // Re-render the main data table to reflect updated dates (if main dates were reset)
                displayDataTable(processedData);

                showDetailMessage(`Alle Änderungen für ${currentSelectedItem.name} wurden zurückgesetzt.`, 'success');
            });


            // Navigation logic for main tabs
            navItems.forEach(item => {
                item.addEventListener('click', function() {
                    navItems.forEach(nav => nav.classList.remove('active'));
                    this.classList.add('active');

                    tabContents.forEach(content => content.classList.remove('active'));
                    const targetTabId = this.dataset.tab;
                    document.getElementById(targetTabId).classList.add('active');

                    detailPanel.classList.remove('open'); // Close detail panel when switching main tabs
                    const currentSelected = document.querySelector('.data-table tbody tr.selected');
                    if (currentSelected) {
                        currentSelected.classList.remove('selected');
                    }
                    currentSelectedRowId = null;
                    currentSelectedItem = null; // Clear selected item

                    if (targetTabId === 'dataTabContent') {
                        adjustDetailPanelPosition();
                    }
                });
            });

            // Navigation logic for detail panel tabs
            detailNavItems.forEach(item => {
                item.addEventListener('click', function() {
                    detailNavItems.forEach(nav => nav.classList.remove('active'));
                    this.classList.add('active');

                    detailTabPanes.forEach(pane => pane.classList.remove('active'));
                    const targetDetailTabId = this.dataset.detailTab;
                    document.getElementById(targetDetailTabId).classList.add('active');
                });
            });

            // Initial call and on resize
            adjustDetailPanelPosition();
            window.addEventListener('resize', adjustDetailPanelPosition);
        });
    </script>
</body>
</html>
